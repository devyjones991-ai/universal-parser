"""–û—Å–Ω–æ–≤–Ω—ã–µ –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ Telegram-–±–æ—Ç–∞."""
from __future__ import annotations

import asyncio
import io
from typing import Any, Dict, List, Optional
import json
from typing import Iterable, List

import pandas as pd
from aiogram import Bot, Dispatcher, types, F
from aiogram.filters import Command
from aiogram.types import (
    BufferedInputFile,
    InlineKeyboardButton,
    InlineKeyboardMarkup,
)
from urllib.parse import quote_plus, unquote_plus

from aiogram.types import BufferedInputFile, InlineKeyboardButton, InlineKeyboardMarkup

from alerts.checker import AlertChecker
from alerts.service import AlertNotFoundError, AlertService, AlertServiceError
from config import settings, parsing_profiles
from aiogram import F, Router
from aiogram.filters import Command, CommandStart
from aiogram.fsm.context import FSMContext
from aiogram.types import (
    BufferedInputFile,
    CallbackQuery,
    Message,
    ReplyKeyboardRemove,
)

from bot import bot, dp
from bot.keyboards import (
    MAIN_MENU,
    build_import_confirmation_keyboard,
    build_results_actions,
)
from bot.services import Alert, ImportBatch, add_alert, register_import
from bot.states import AlertScenario, ImportListScenario
from config import parsing_profiles, settings
from db import get_recent_results, save_results
from navigator import build_help_section
from parser import UniversalParser
from db import save_results, get_recent_results
from navigator.suppliers import search_suppliers, OPEN_CATALOGS
from navigator.guides import get_section, get_paginated_faq
from navigator.logistics import Carrier, find_carriers, initialise_storage

bot = Bot(token=settings.TELEGRAM_BOT_TOKEN)
dp = Dispatcher()
alert_service = AlertService()
alert_checker = AlertChecker(bot=bot, service=alert_service)
monitoring_storage = MonitoringStorage()

router = Router(name="main")


SUPPLIERS_PAGE_SIZE = 5
LOGISTICS_PAGE_SIZE = 5
FAQ_PAGE_SIZE = 2


# –ü—Ä–æ–≤–µ—Ä–∫–∞ –¥–æ—Å—Ç—É–ø–∞
def is_admin(user_id: int) -> bool:
    return user_id == settings.TELEGRAM_CHAT_ID or user_id in settings.ADMIN_CHAT_IDS


def _make_callback(prefix: str, page: int, *parts: str) -> str:
    encoded = [quote_plus(str(page))]
    encoded.extend(quote_plus(part or "") for part in parts)
    return "|".join([prefix, *encoded])


def _parse_callback(data: str) -> tuple[str, int, list[str]]:
    parts = data.split("|")
    prefix = parts[0]
    if len(parts) < 2:
        return prefix, 1, []
    page = int(unquote_plus(parts[1])) if parts[1] else 1
    payload = [unquote_plus(part) for part in parts[2:]] if len(parts) > 2 else []
    return prefix, max(1, page), payload


def _build_pagination_keyboard(
    prefix: str, page: int, has_prev: bool, has_next: bool, payload: list[str]
) -> Optional[InlineKeyboardMarkup]:
    buttons = []
    if has_prev:
        buttons.append(
            InlineKeyboardButton(
                text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥",
                callback_data=_make_callback(prefix, page - 1, *payload),
            )
        )
    if has_next:
        buttons.append(
            InlineKeyboardButton(
                text="‚û°Ô∏è –í–ø–µ—Ä—ë–¥",
                callback_data=_make_callback(prefix, page + 1, *payload),
            )
        )
    if not buttons:
        return None
    return InlineKeyboardMarkup(inline_keyboard=[buttons])


def _format_supplier_item(item: Dict[str, Any]) -> str:
    name = item.get("name") or item.get("title") or "–ë–µ–∑ –Ω–∞–∑–≤–∞–Ω–∏—è"
    parts = [f"üè∑Ô∏è {name}"]
    if item.get("category"):
        parts.append(f"üìÇ –ö–∞—Ç–µ–≥–æ—Ä–∏—è: {item['category']}")
    if item.get("location"):
        parts.append(f"üìç –ì–æ—Ä–æ–¥: {item['location']}")
    if item.get("phone"):
        parts.append(f"‚òéÔ∏è –¢–µ–ª–µ—Ñ–æ–Ω: {item['phone']}")
    if item.get("website"):
        parts.append(f"üåê {item['website']}")
    return "\n".join(parts)


def _format_carrier_item(carrier: Carrier) -> str:
    parts = [f"üöö {carrier.name}"]
    if carrier.regions:
        parts.append(f"üó∫Ô∏è –†–µ–≥–∏–æ–Ω—ã: {', '.join(carrier.regions)}")
    if carrier.vehicle_types:
        parts.append(f"üöõ –¢—Ä–∞–Ω—Å–ø–æ—Ä—Ç: {', '.join(carrier.vehicle_types)}")
    if carrier.phone:
        parts.append(f"‚òéÔ∏è {carrier.phone}")
    if carrier.email:
        parts.append(f"‚úâÔ∏è {carrier.email}")
    if carrier.rating is not None:
        parts.append(f"‚≠ê –†–µ–π—Ç–∏–Ω–≥: {carrier.rating:.1f}")
    return "\n".join(parts)


def _format_section(key: str) -> str:
    section = get_section(key)
    header = f"üìò {section.title} (–æ–±–Ω–æ–≤–ª–µ–Ω–æ {section.updated_at:%d.%m.%Y %H:%M} UTC)"
    return "\n\n".join([header, "\n".join(section.content)])


async def _send_supplier_results(
    message: types.Message,
    query: str,
    source: str,
    page: int,
    *,
    edit: bool = False,
) -> None:
    try:
        result = await search_suppliers(
            query=query,
            source_name=source,
            page=page,
            limit=SUPPLIERS_PAGE_SIZE + 1,
        )
    except KeyError:
        text = f"‚ùå –ò—Å—Ç–æ—á–Ω–∏–∫ '{source}' –Ω–µ –Ω–∞–π–¥–µ–Ω."
        keyboard = None
    except Exception as exc:
        text = f"‚ùå –û—à–∏–±–∫–∞ –ø–æ–∏—Å–∫–∞ –ø–æ—Å—Ç–∞–≤—â–∏–∫–æ–≤: {exc}"
        keyboard = None
    else:
        items = result.results[:SUPPLIERS_PAGE_SIZE]
        has_more = len(result.results) > SUPPLIERS_PAGE_SIZE
        has_prev = page > 1
        keyboard = _build_pagination_keyboard(
            "sup", page, has_prev, has_more, [source, query]
        )
        if items:
            offset = (page - 1) * SUPPLIERS_PAGE_SIZE
            body = []
            for idx, item in enumerate(items, start=1):
                body.append(f"{offset + idx}. {_format_supplier_item(item)}")
            text = (
                f"üì¶ –ò—Å—Ç–æ—á–Ω–∏–∫: {source}\n"
                f"üîé –ó–∞–ø—Ä–æ—Å: {query}\n"
                f"–°—Ç—Ä–∞–Ω–∏—Ü–∞ {page}\n\n"
                + "\n\n".join(body)
            )
        else:
            text = f"‚ö†Ô∏è –ü–æ –∑–∞–ø—Ä–æ—Å—É '{query}' –Ω–∏—á–µ–≥–æ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ."
            keyboard = None

    if edit:
        await message.edit_text(text, reply_markup=keyboard, disable_web_page_preview=True)
    else:
        await message.reply(text, reply_markup=keyboard, disable_web_page_preview=True)


async def _send_logistics_results(
    message: types.Message,
    query: Optional[str],
    regions: List[str],
    min_rating: Optional[float],
    page: int,
    *,
    edit: bool = False,
) -> None:
    initialise_storage()
    carriers = find_carriers(
        query=query,
        regions=regions or None,
        min_rating=min_rating,
        limit=LOGISTICS_PAGE_SIZE + 1,
        offset=(page - 1) * LOGISTICS_PAGE_SIZE,
    )
    items = carriers[:LOGISTICS_PAGE_SIZE]
    has_more = len(carriers) > LOGISTICS_PAGE_SIZE
    has_prev = page > 1
    payload = [query or "", ",".join(regions), str(min_rating or "")]
    keyboard = _build_pagination_keyboard("log", page, has_prev, has_more, payload)

    if items:
        offset = (page - 1) * LOGISTICS_PAGE_SIZE
        body = []
        for idx, carrier in enumerate(items, start=1):
            body.append(f"{offset + idx}. {_format_carrier_item(carrier)}")
        filters = ["üöö –ö–∞—Ç–∞–ª–æ–≥ –ø–µ—Ä–µ–≤–æ–∑—á–∏–∫–æ–≤"]
        if query:
            filters.append(f"üîç –ò–º—è —Å–æ–¥–µ—Ä–∂–∏—Ç: {query}")
        if regions:
            filters.append(f"üåç –†–µ–≥–∏–æ–Ω—ã: {', '.join(regions)}")
        if min_rating is not None:
            filters.append(f"‚≠ê –†–µ–π—Ç–∏–Ω–≥ –æ—Ç {min_rating}")
        text = "\n".join(filters) + "\n\n" + "\n\n".join(body)
    else:
        text = "‚ö†Ô∏è –ü–µ—Ä–µ–≤–æ–∑—á–∏–∫–∏ –ø–æ –∑–∞–¥–∞–Ω–Ω—ã–º —É—Å–ª–æ–≤–∏—è–º –Ω–µ –Ω–∞–π–¥–µ–Ω—ã."
        keyboard = None

    if edit:
        await message.edit_text(text, reply_markup=keyboard, disable_web_page_preview=True)
    else:
        await message.reply(text, reply_markup=keyboard, disable_web_page_preview=True)


async def _send_faq(message: types.Message, page: int, *, edit: bool = False) -> None:
    items, total_pages = get_paginated_faq(page=page, per_page=FAQ_PAGE_SIZE)
    if not items and total_pages and page > total_pages:
        items, total_pages = get_paginated_faq(page=total_pages, per_page=FAQ_PAGE_SIZE)
        page = total_pages

    has_prev = page > 1
    has_next = page < total_pages
    keyboard = _build_pagination_keyboard("faq", page, has_prev, has_next, [])

    if items:
        pairs = []
        for idx in range(0, len(items), 2):
            question = items[idx]
            answer = items[idx + 1] if idx + 1 < len(items) else ""
            pairs.append(f"‚ùì {question}\nüí° {answer}")
        text = "üìö FAQ\n\n" + "\n\n".join(pairs) + f"\n\n–°—Ç—Ä–∞–Ω–∏—Ü–∞ {page} –∏–∑ {total_pages}"
    else:
        text = "FAQ –ø–æ–∫–∞ –ø—É—Å—Ç."

    if edit:
        await message.edit_text(text, reply_markup=keyboard, disable_web_page_preview=True)
    else:
        await message.reply(text, reply_markup=keyboard, disable_web_page_preview=True)

@dp.message(Command("start"))
async def cmd_start(message: types.Message):
async def ensure_admin_message(message: Message) -> bool:
    if not is_admin(message.from_user.id):
        await message.reply("‚ùå –î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â—ë–Ω")
        return
    
    await message.reply(
        "üöÄ –£–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω—ã–π –ø–∞—Ä—Å–µ—Ä –∑–∞–ø—É—â–µ–Ω!\n\n"
        "–ö–æ–º–∞–Ω–¥—ã:\n"
        "/profiles - —Å–ø–∏—Å–æ–∫ –ø—Ä–æ—Ñ–∏–ª–µ–π\n"
        "/parse <url> - –ø–∞—Ä—Å–∏—Ç—å URL\n"
        "/run <profile> - –∑–∞–ø—É—Å—Ç–∏—Ç—å –ø—Ä–æ—Ñ–∏–ª—å\n"
        "/results - –ø–æ—Å–ª–µ–¥–Ω–∏–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã\n"
        "/export - —ç–∫—Å–ø–æ—Ä—Ç –≤ Excel/CSV\n"
        "/alert_add <sku> <—É—Å–ª–æ–≤–∏–µ> <–ø–æ—Ä–æ–≥> - —Å–æ–∑–¥–∞—Ç—å –∞–ª–µ—Ä—Ç\n"
        "/alert_list - —Å–ø–∏—Å–æ–∫ –∞–ª–µ—Ä—Ç–æ–≤\n"
        "/alert_delete <id> - —É–¥–∞–ª–∏—Ç—å –∞–ª–µ—Ä—Ç\n"
        "/alert_pause <id> [resume] - –ø–∞—É–∑–∞ –∏–ª–∏ –∑–∞–ø—É—Å–∫"
        await message.answer("‚ùå –î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â—ë–Ω")
        return False
    return True


async def ensure_admin_callback(callback: CallbackQuery) -> bool:
    if not is_admin(callback.from_user.id):
        await callback.answer("–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—Ä–∞–≤", show_alert=True)
        return False
    return True


@router.message(CommandStart())
async def cmd_start(message: Message) -> None:
    if not await ensure_admin_message(message):
        return

    text = (
        "üöÄ –£–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω—ã–π –ø–∞—Ä—Å–µ—Ä –≥–æ—Ç–æ–≤ –∫ —Ä–∞–±–æ—Ç–µ!\n"
        "–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ –≤ –≥–ª–∞–≤–Ω–æ–º –º–µ–Ω—é –∏–ª–∏ –≤–æ—Å–ø–æ–ª—å–∑—É–π—Ç–µ—Å—å –∫–æ–º–∞–Ω–¥–∞–º–∏."
    )
    await message.answer(text, reply_markup=MAIN_MENU)


@router.message(Command("help"))
@router.message(F.text == "‚ÑπÔ∏è –ü–æ–º–æ—â—å")
async def cmd_help(message: Message) -> None:
    if not await ensure_admin_message(message):
        return


    commands: Iterable[str] = (
        "/profiles ‚Äî —Å–ø–∏—Å–æ–∫ –ø—Ä–æ—Ñ–∏–ª–µ–π",
        "/parse <url> ‚Äî —Å–ø–∞—Ä—Å–∏—Ç—å –ø—Ä–æ–∏–∑–≤–æ–ª—å–Ω—ã–π URL",
        "/run <profile> ‚Äî –≤—ã–ø–æ–ª–Ω–∏—Ç—å –ø—Ä–æ—Ñ–∏–ª—å",
        "/results ‚Äî –ø–æ—Å–ª–µ–¥–Ω–∏–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã",
        "/export ‚Äî —ç–∫—Å–ø–æ—Ä—Ç –ø–æ—Å–ª–µ–¥–Ω–∏—Ö –¥–∞–Ω–Ω—ã—Ö",
    )
    help_text = build_help_section(commands)
    await message.answer(help_text, reply_markup=MAIN_MENU)


@router.message(Command("profiles"))
async def cmd_profiles(message: Message) -> None:
    if not await ensure_admin_message(message):
        return

    if not parsing_profiles:
        await message.answer("‚ùå –ü—Ä–æ—Ñ–∏–ª–∏ –Ω–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω—ã", reply_markup=MAIN_MENU)
        return


    text = "üìã –î–æ—Å—Ç—É–ø–Ω—ã–µ –ø—Ä–æ—Ñ–∏–ª–∏:\n\n"
    for key, profile in parsing_profiles.items():
        text += f"üî∏ `{key}` - {profile['name']}\n"

    await message.reply(text, parse_mode="Markdown")


@dp.message(Command("alert_add"))
async def cmd_alert_add(message: types.Message):
    if not is_admin(message.from_user.id):
        return

    parts = message.text.split()
    if len(parts) < 4:
        await message.reply("‚ùå –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: /alert_add <sku> <—É—Å–ª–æ–≤–∏–µ> <–ø–æ—Ä–æ–≥>")
        return

    sku = parts[1]
    condition_type = parts[2]
    threshold_raw = parts[3]

    try:
        threshold = float(threshold_raw.replace(",", "."))
    except ValueError:
        await message.reply("‚ùå –ü–æ—Ä–æ–≥ –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º")
        return

    alert = await alert_service.add_alert(
        message.from_user.id, sku, condition_type, threshold
    )

    await message.reply(
        "‚úÖ –ê–ª–µ—Ä—Ç —Å–æ–∑–¥–∞–Ω\n"
        f"ID: {alert.id}\n"
        f"SKU: {alert.sku}\n"
        f"–£—Å–ª–æ–≤–∏–µ: {condition_type} {threshold}"
    )


@dp.message(Command("alert_list"))
async def cmd_alert_list(message: types.Message):
    if not is_admin(message.from_user.id):
        return

    alerts = await alert_service.list_alerts(message.from_user.id)

    if not alerts:
        await message.reply("‚ÑπÔ∏è –£ –≤–∞—Å –Ω–µ—Ç –Ω–∞—Å—Ç—Ä–æ–µ–Ω–Ω—ã—Ö –∞–ª–µ—Ä—Ç–æ–≤")
        return

    lines = ["üì¨ –í–∞—à–∏ –∞–ª–µ—Ä—Ç—ã:"]
    for alert in alerts:
        status = "–∞–∫—Ç–∏–≤–µ–Ω" if alert.is_active else "–Ω–∞ –ø–∞—É–∑–µ"
        last_value = (
            f", –ø–æ—Å–ª–µ–¥–Ω–µ–µ –∑–Ω–∞—á–µ–Ω–∏–µ: {alert.last_value:.2f}"
            if alert.last_value is not None
            else ""
        )
        lines.append(
            f"#{alert.id}: SKU {alert.sku} ‚Äî {alert.condition_type} {alert.threshold:.2f} ({status}{last_value})"
        )

    await message.reply("\n".join(lines))


@dp.message(Command("alert_delete"))
async def cmd_alert_delete(message: types.Message):
    if not is_admin(message.from_user.id):
        return

    parts = message.text.split()
    if len(parts) < 2:
        await message.reply("‚ùå –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: /alert_delete <id>")
        return

    try:
        alert_id = int(parts[1])
    except ValueError:
        await message.reply("‚ùå ID –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º")
        return

    try:
        await alert_service.delete_alert(message.from_user.id, alert_id)
    except AlertNotFoundError:
        await message.reply("‚ùå –ê–ª–µ—Ä—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω")
        return
    except AlertServiceError as error:
        await message.reply(f"‚ùå {error}")
        return

    await message.reply(f"üóëÔ∏è –ê–ª–µ—Ä—Ç #{alert_id} —É–¥–∞–ª—ë–Ω")


@dp.message(Command("alert_pause"))
async def cmd_alert_pause(message: types.Message):
    if not is_admin(message.from_user.id):
        return

    parts = message.text.split()
    if len(parts) < 2:
        await message.reply("‚ùå –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: /alert_pause <id> [resume]")
        return

    try:
        alert_id = int(parts[1])
    except ValueError:
        await message.reply("‚ùå ID –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º")
        return

    action = parts[2].lower() if len(parts) > 2 else "pause"

    try:
        if action in {"resume", "start", "run", "on"}:
            alert = await alert_service.resume_alert(message.from_user.id, alert_id)
            await message.reply(f"‚ñ∂Ô∏è –ê–ª–µ—Ä—Ç #{alert.id} —Å–Ω–æ–≤–∞ –∞–∫—Ç–∏–≤–µ–Ω")
        else:
            alert = await alert_service.pause_alert(message.from_user.id, alert_id)
            await message.reply(f"‚è∏Ô∏è –ê–ª–µ—Ä—Ç #{alert.id} –ø–æ—Å—Ç–∞–≤–ª–µ–Ω –Ω–∞ –ø–∞—É–∑—É")
    except AlertNotFoundError:
        await message.reply("‚ùå –ê–ª–µ—Ä—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω")
    except AlertServiceError as error:
        await message.reply(f"‚ùå {error}")

@dp.message(Command("parse"))
async def cmd_parse(message: types.Message):
    if not is_admin(message.from_user.id):
    lines: List[str] = ["üìã –î–æ—Å—Ç—É–ø–Ω—ã–µ –ø—Ä–æ—Ñ–∏–ª–∏:"]
    for key, profile in parsing_profiles.items():
        lines.append(f"üî∏ <code>{key}</code> ‚Äî {profile['name']}")

    await message.answer("\n".join(lines), reply_markup=MAIN_MENU)


@router.message(Command("parse"))
async def cmd_parse(message: Message) -> None:
    if not await ensure_admin_message(message):
        return

    args = message.text.split(" ", 1)
    if len(args) < 2:
        await message.answer("‚ùå –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: /parse <url>")
        return

    url = args[1].strip()
    await message.answer(f"üîÑ –ü–∞—Ä—Å–∏–º {url}‚Ä¶", reply_markup=ReplyKeyboardRemove())

    try:
        async with UniversalParser() as parser:
            results = await parser.parse_url(url)
    except Exception as exc:  # pragma: no cover - —Å–µ—Ç–µ–≤—ã–µ –æ—à–∏–±–∫–∏
        await message.answer(f"‚ùå –û—à–∏–±–∫–∞: {exc}", reply_markup=MAIN_MENU)
        return

    if not results:
        await message.answer("‚ùå –î–∞–Ω–Ω—ã–µ –Ω–µ –Ω–∞–π–¥–µ–Ω—ã", reply_markup=MAIN_MENU)
        return

    save_results("manual_parse", results)
    preview = json.dumps(results[:5], ensure_ascii=False, indent=2)
    text = f"‚úÖ –ù–∞–π–¥–µ–Ω–æ {len(results)} —ç–ª–µ–º–µ–Ω—Ç–æ–≤\n<pre>{preview}</pre>"
    await message.answer(text, reply_markup=MAIN_MENU)


async def _run_profile(profile_name: str) -> List[dict]:
    async with UniversalParser() as parser:
        return await parser.parse_by_profile(profile_name)


@router.message(Command("run"))
async def cmd_run(message: Message) -> None:
    if not await ensure_admin_message(message):
        return

    args = message.text.split(" ", 1)
    if len(args) < 2:
        await message.answer("‚ùå –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: /run <profile_name>")
        return

    profile_name = args[1].strip()
    if profile_name not in parsing_profiles:
        await message.answer(f"‚ùå –ü—Ä–æ—Ñ–∏–ª—å '{profile_name}' –Ω–µ –Ω–∞–π–¥–µ–Ω")
        return

    await message.answer(f"üîÑ –ó–∞–ø—É—Å–∫–∞–µ–º –ø—Ä–æ—Ñ–∏–ª—å '{profile_name}'‚Ä¶", reply_markup=ReplyKeyboardRemove())

    try:
        results = await _run_profile(profile_name)
    except Exception as exc:  # pragma: no cover - —Å–µ—Ç–µ–≤—ã–µ –æ—à–∏–±–∫–∏
        await message.answer(f"‚ùå –û—à–∏–±–∫–∞: {exc}", reply_markup=MAIN_MENU)
        return

    if not results:
        await message.answer("‚ùå –î–∞–Ω–Ω—ã–µ –Ω–µ –Ω–∞–π–¥–µ–Ω—ã", reply_markup=MAIN_MENU)
        return

    save_results(profile_name, results)
    text_lines = [
        f"‚úÖ –ü—Ä–æ—Ñ–∏–ª—å '{profile_name}' –≤—ã–ø–æ–ª–Ω–µ–Ω",
        f"–ù–∞–π–¥–µ–Ω–æ —ç–ª–µ–º–µ–Ω—Ç–æ–≤: {len(results)}",
    ]
    for idx, result in enumerate(results[:3], start=1):
        text_lines.append(f"{idx}. {json.dumps(result, ensure_ascii=False)}")
    if len(results) > 3:
        text_lines.append(f"‚Ä¶ –∏ –µ—â—ë {len(results) - 3} —ç–ª–µ–º–µ–Ω—Ç–æ–≤")

    await message.answer("\n".join(text_lines), reply_markup=MAIN_MENU)


async def _send_results(message: Message) -> None:
    results = get_recent_results(limit=100)
    if not results:
        await message.answer("‚ùå –†–µ–∑—É–ª—å—Ç–∞—Ç—ã –Ω–µ –Ω–∞–π–¥–µ–Ω—ã", reply_markup=MAIN_MENU)
        return

    text_lines = [f"üìä –ü–æ—Å–ª–µ–¥–Ω–∏–µ {len(results)} —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤:"]
    for result in results[:10]:
        text_lines.append(
            f"üî∏ {result['timestamp']} ‚Äî {result['profile_name']}: {result['count']} —ç–ª–µ–º–µ–Ω—Ç–æ–≤"
        )

    latest_profile = results[0]["profile_name"]
    await message.answer(
        "\n".join(text_lines),
        reply_markup=build_results_actions(latest_profile),
    )


@router.message(Command("results"))
@router.message(F.text == "üìä –ü–æ—Å–ª–µ–¥–Ω–∏–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã")
async def cmd_results(message: Message) -> None:
    if not await ensure_admin_message(message):
        return
    await _send_results(message)


@router.message(Command("export"))
async def cmd_export(message: Message) -> None:
    if not await ensure_admin_message(message):
        return

    results = get_recent_results(limit=1000)
    if not results:
        await message.answer("‚ùå –ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –¥–ª—è —ç–∫—Å–ø–æ—Ä—Ç–∞", reply_markup=MAIN_MENU)
        return

    dataframe = pd.DataFrame(results)
    buffer = io.BytesIO()
    with pd.ExcelWriter(buffer, engine="openpyxl") as writer:
        dataframe.to_excel(writer, index=False, sheet_name="Results")
    buffer.seek(0)

    file = BufferedInputFile(buffer.read(), filename="parsing_results.xlsx")
    await message.answer_document(file, caption=f"üìà –≠–∫—Å–ø–æ—Ä—Ç: {len(results)} –∑–∞–ø–∏—Å–µ–π")


@dp.callback_query(F.data.startswith("alert:"))
async def alert_callback_handler(callback: types.CallbackQuery):
    if not is_admin(callback.from_user.id):
        await callback.answer("–ù–µ—Ç –¥–æ—Å—Ç—É–ø–∞", show_alert=True)
        return

    parts = callback.data.split(":")
    if len(parts) != 3:
        await callback.answer("–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π –∑–∞–ø—Ä–æ—Å", show_alert=True)
        return

    _, action, alert_id_raw = parts

    try:
        alert_id = int(alert_id_raw)
    except ValueError:
        await callback.answer("–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π ID", show_alert=True)
        return

    try:
        if action == "pause":
            await alert_service.pause_alert(callback.from_user.id, alert_id)
            await callback.answer("–ê–ª–µ—Ä—Ç –ø—Ä–∏–æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω")
        elif action == "resume":
            await alert_service.resume_alert(callback.from_user.id, alert_id)
            await callback.answer("–ê–ª–µ—Ä—Ç –∑–∞–ø—É—â–µ–Ω")
        elif action == "delete":
            await alert_service.delete_alert(callback.from_user.id, alert_id)
            await callback.answer("–ê–ª–µ—Ä—Ç —É–¥–∞–ª—ë–Ω")
            await callback.message.edit_reply_markup(reply_markup=None)
            return
        else:
            await callback.answer("–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ–µ –¥–µ–π—Å—Ç–≤–∏–µ", show_alert=True)
            return
    except AlertServiceError as error:
        await callback.answer(str(error), show_alert=True)
        return

    keyboard = build_alert_keyboard(alert_id)
    await callback.message.edit_reply_markup(reply_markup=keyboard)

async def start_bot():
@router.message(Command("alert"))
@router.message(F.text == "‚ûï –î–æ–±–∞–≤–∏—Ç—å –∞–ª–µ—Ä—Ç")
async def start_alert(message: Message, state: FSMContext) -> None:
    if not await ensure_admin_message(message):
        return

    await state.set_state(AlertScenario.waiting_for_name)
    await message.answer("–í–≤–µ–¥–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ –∞–ª–µ—Ä—Ç–∞:", reply_markup=ReplyKeyboardRemove())


@router.message(AlertScenario.waiting_for_name)
async def alert_name(message: Message, state: FSMContext) -> None:
    name = message.text.strip()
    if not name:
        await message.answer("–ù–∞–∑–≤–∞–Ω–∏–µ –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.")
        return

    await state.update_data(name=name)
    await state.set_state(AlertScenario.waiting_for_url)
    await message.answer("–£–∫–∞–∂–∏—Ç–µ URL, –∫–æ—Ç–æ—Ä—ã–π –Ω—É–∂–Ω–æ –æ—Ç—Å–ª–µ–∂–∏–≤–∞—Ç—å:")


@router.message(AlertScenario.waiting_for_url)
async def alert_url(message: Message, state: FSMContext) -> None:
    url = message.text.strip()
    if not url.startswith("http"):
        await message.answer("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ –∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π URL (http/https).")
        return

    await state.update_data(url=url)
    await state.set_state(AlertScenario.waiting_for_conditions)
    await message.answer("–ü–µ—Ä–µ—á–∏—Å–ª–∏—Ç–µ —É—Å–ª–æ–≤–∏—è/–∫–ª—é—á–µ–≤—ã–µ —Å–ª–æ–≤–∞ —á–µ—Ä–µ–∑ –∑–∞–ø—è—Ç—É—é:")


@router.message(AlertScenario.waiting_for_conditions)
async def alert_finish(message: Message, state: FSMContext) -> None:
    conditions = [item.strip() for item in message.text.split(",") if item.strip()]
    if not conditions:
        await message.answer("–ù—É–∂–Ω–æ —É–∫–∞–∑–∞—Ç—å —Ö–æ—Ç—è –±—ã –æ–¥–Ω–æ —É—Å–ª–æ–≤–∏–µ. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.")
        return

    data = await state.get_data()
    alert = Alert(name=data["name"], url=data["url"], conditions=conditions)
    add_alert(alert)
    await state.clear()

    text = (
        f"‚úÖ –ê–ª–µ—Ä—Ç ¬´{alert.name}¬ª —Å–æ—Ö—Ä–∞–Ω—ë–Ω."
        f"\nURL: {alert.url}"
        f"\n–£—Å–ª–æ–≤–∏—è: {', '.join(alert.conditions)}"
    )
    await message.answer(text, reply_markup=MAIN_MENU)


@router.message(Command("import"))
@router.message(F.text == "üì• –ò–º–ø–æ—Ä—Ç —Å–ø–∏—Å–∫–∞")
async def start_import(message: Message, state: FSMContext) -> None:
    if not await ensure_admin_message(message):
        return

    await state.set_state(ImportListScenario.waiting_for_payload)
    await message.answer(
        "–û—Ç–ø—Ä–∞–≤—å—Ç–µ —Å–ø–∏—Å–æ–∫ —Å—Å—ã–ª–æ–∫ –∏–ª–∏ –∑–Ω–∞—á–µ–Ω–∏–π. –ú–æ–∂–Ω–æ –≤—Å—Ç–∞–≤–∏—Ç—å —Ç–µ–∫—Å—Ç –±–ª–æ–∫–æ–º –∏–ª–∏ –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —Ñ–∞–π–ª .txt.",
        reply_markup=ReplyKeyboardRemove(),
    )


@router.message(ImportListScenario.waiting_for_payload)
async def import_payload(message: Message, state: FSMContext) -> None:
    content = message.text or message.caption
    if not content:
        await message.answer("–ù–µ —É–¥–∞–ª–æ—Å—å –ø—Ä–æ—á–∏—Ç–∞—Ç—å –¥–∞–Ω–Ω—ã–µ. –í—Å—Ç–∞–≤—å—Ç–µ —Ç–µ–∫—Å—Ç —Å–æ —Å–ø–∏—Å–∫–æ–º.")
        return

    parts = [item.strip() for item in content.replace(",", "\n").splitlines() if item.strip()]
    if not parts:
        await message.answer("–°–ø–∏—Å–æ–∫ –ø—É—Å—Ç. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.")
        return

    await state.update_data(items=parts)
    await state.set_state(ImportListScenario.waiting_for_confirmation)
    await message.answer(
        f"–ü–æ–ª—É—á–µ–Ω–æ {len(parts)} —ç–ª–µ–º–µ–Ω—Ç–æ–≤. –°–æ—Ö—Ä–∞–Ω–∏—Ç—å?",
        reply_markup=build_import_confirmation_keyboard(),
    )


@router.callback_query(ImportListScenario.waiting_for_confirmation, F.data == "import:confirm")
async def import_confirm(callback: CallbackQuery, state: FSMContext) -> None:
    if not await ensure_admin_callback(callback):
        return

    data = await state.get_data()
    items = data.get("items", [])
    register_import(ImportBatch(items=items))
    await state.clear()

    await callback.message.answer(
        f"‚úÖ –ò–º–ø–æ—Ä—Ç —Å–æ—Ö—Ä–∞–Ω—ë–Ω. –î–æ–±–∞–≤–ª–µ–Ω–æ {len(items)} —ç–ª–µ–º–µ–Ω—Ç–æ–≤.",
        reply_markup=MAIN_MENU,
    )
    await callback.answer("–ò–º–ø–æ—Ä—Ç —Å–æ—Ö—Ä–∞–Ω—ë–Ω")


@router.callback_query(ImportListScenario.waiting_for_confirmation, F.data == "import:cancel")
async def import_cancel(callback: CallbackQuery, state: FSMContext) -> None:
    if not await ensure_admin_callback(callback):
        return

    await state.clear()
    await callback.message.answer("–ò–º–ø–æ—Ä—Ç –æ—Ç–º–µ–Ω—ë–Ω.", reply_markup=MAIN_MENU)
    await callback.answer("–û—Ç–º–µ–Ω–µ–Ω–æ")


@router.callback_query(F.data.startswith("results:rerun:"))
async def results_rerun(callback: CallbackQuery) -> None:
    if not await ensure_admin_callback(callback):
        return

    _, _, profile_name = callback.data.partition("results:rerun:")
    profile_name = profile_name.strip()

    if profile_name not in parsing_profiles:
        await callback.message.answer(f"‚ùå –ü—Ä–æ—Ñ–∏–ª—å '{profile_name}' –Ω–µ –Ω–∞–π–¥–µ–Ω.")
        await callback.answer("–û—à–∏–±–∫–∞", show_alert=True)
        return

    try:
        results = await _run_profile(profile_name)
    except Exception as exc:  # pragma: no cover - —Å–µ—Ç–µ–≤—ã–µ –æ—à–∏–±–∫–∏
        await callback.message.answer(f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–ø—É—Å–∫–µ: {exc}")
        await callback.answer("–û—à–∏–±–∫–∞", show_alert=True)
        return

    if not results:
        await callback.message.answer("‚ùå –î–∞–Ω–Ω—ã–µ –Ω–µ –Ω–∞–π–¥–µ–Ω—ã")
        await callback.answer("–ì–æ—Ç–æ–≤–æ")
        return

    save_results(profile_name, results)
    await callback.message.answer(
        f"‚úÖ –ü–æ–≤—Ç–æ—Ä–Ω—ã–π –∑–∞–ø—É—Å–∫ –ø—Ä–æ—Ñ–∏–ª—è '{profile_name}' –∑–∞–≤–µ—Ä—à—ë–Ω. –ù–∞–π–¥–µ–Ω–æ {len(results)} —ç–ª–µ–º–µ–Ω—Ç–æ–≤.",
        reply_markup=MAIN_MENU,
    )
    await callback.answer("–ì–æ—Ç–æ–≤–æ")


@router.callback_query(F.data.startswith("results:export:"))
async def results_export(callback: CallbackQuery) -> None:
    if not await ensure_admin_callback(callback):
        return

    _, _, profile_name = callback.data.partition("results:export:")
    profile_name = profile_name.strip()

    results = [result for result in get_recent_results(limit=1000) if result["profile_name"] == profile_name]
    if not results:
        await callback.message.answer("‚ùå –ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –¥–ª—è —ç–∫—Å–ø–æ—Ä—Ç–∞ –ø–æ –≤—ã–±—Ä–∞–Ω–Ω–æ–º—É –ø—Ä–æ—Ñ–∏–ª—é.")
        await callback.answer("–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö", show_alert=True)
        return

    dataframe = pd.DataFrame(results)
    buffer = io.BytesIO()
    with pd.ExcelWriter(buffer, engine="openpyxl") as writer:
        dataframe.to_excel(writer, index=False, sheet_name=profile_name[:31] or "Results")
    buffer.seek(0)

    file = BufferedInputFile(buffer.read(), filename=f"{profile_name}_results.xlsx")
    await callback.message.answer_document(file, caption=f"üìà –≠–∫—Å–ø–æ—Ä—Ç –ø—Ä–æ—Ñ–∏–ª—è {profile_name}")
    await callback.answer("–≠–∫—Å–ø–æ—Ä—Ç –≥–æ—Ç–æ–≤")


dp.include_router(router)


async def start_bot() -> None:
    print("ü§ñ Telegram –±–æ—Ç –∑–∞–ø—É—â–µ–Ω!")
    alert_checker.start()
    try:
        await dp.start_polling(bot)
    finally:
        await alert_checker.shutdown()


if __name__ == "__main__":
    asyncio.run(start_bot())
