"""–û—Å–Ω–æ–≤–Ω—ã–µ –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ Telegram-–±–æ—Ç–∞."""
from __future__ import annotations

import asyncio
import io
import json
from typing import Iterable, List

import pandas as pd
from aiogram import F, Router
from aiogram.filters import Command, CommandStart
from aiogram.fsm.context import FSMContext
from aiogram.types import (
    BufferedInputFile,
    CallbackQuery,
    Message,
    ReplyKeyboardRemove,
)

from bot import bot, dp
from bot.keyboards import (
    MAIN_MENU,
    build_import_confirmation_keyboard,
    build_results_actions,
)
from bot.services import Alert, ImportBatch, add_alert, register_import
from bot.states import AlertScenario, ImportListScenario
from config import parsing_profiles, settings
from db import get_recent_results, save_results
from navigator import build_help_section
from parser import UniversalParser
from db import save_results, get_recent_results
from profiles.monitoring import MonitoringStorage, UserTrackedItem
from profiles.import_export import (
    export_items,
    import_items_from_clipboard,
    import_items_from_file,
)

bot = Bot(token=settings.TELEGRAM_BOT_TOKEN)
dp = Dispatcher()
monitoring_storage = MonitoringStorage()

router = Router(name="main")


def is_admin(user_id: int) -> bool:
    return user_id == settings.TELEGRAM_CHAT_ID or user_id in settings.ADMIN_CHAT_IDS


def _parse_sources(raw_sources: str) -> list[str]:
    return [s.strip() for s in raw_sources.split(",") if s.strip()]


def _parse_monitor_payload(raw: str) -> UserTrackedItem:
    parts = [part.strip() for part in raw.split("|")]
    if len(parts) < 2:
        raise ValueError("–û–∂–∏–¥–∞–µ—Ç—Å—è –º–∏–Ω–∏–º—É–º –¥–≤–∞ –ø–æ–ª—è: –ø—Ä–æ—Ñ–∏–ª—å|–∑–∞–ø—Ä–æ—Å|[SKU]|[–Ω–∞–∑–≤–∞–Ω–∏–µ]|[–∏—Å—Ç–æ—á–Ω–∏–∫–∏]")
    profile, query = parts[0], parts[1]
    sku = parts[2] or None if len(parts) > 2 else None
    title = parts[3] or None if len(parts) > 3 else None
    sources = _parse_sources(parts[4]) if len(parts) > 4 else []
    return UserTrackedItem(
        user_id=0,
        profile=profile,
        query=query,
        sku=sku,
        title=title,
        sources=sources,
    )

@dp.message(Command("start"))
async def cmd_start(message: types.Message):
async def ensure_admin_message(message: Message) -> bool:
    if not is_admin(message.from_user.id):
        await message.answer("‚ùå –î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â—ë–Ω")
        return False
    return True


async def ensure_admin_callback(callback: CallbackQuery) -> bool:
    if not is_admin(callback.from_user.id):
        await callback.answer("–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—Ä–∞–≤", show_alert=True)
        return False
    return True


@router.message(CommandStart())
async def cmd_start(message: Message) -> None:
    if not await ensure_admin_message(message):
        return

    text = (
        "üöÄ –£–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω—ã–π –ø–∞—Ä—Å–µ—Ä –≥–æ—Ç–æ–≤ –∫ —Ä–∞–±–æ—Ç–µ!\n"
        "–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ –≤ –≥–ª–∞–≤–Ω–æ–º –º–µ–Ω—é –∏–ª–∏ –≤–æ—Å–ø–æ–ª—å–∑—É–π—Ç–µ—Å—å –∫–æ–º–∞–Ω–¥–∞–º–∏."
    )
    await message.answer(text, reply_markup=MAIN_MENU)


@router.message(Command("help"))
@router.message(F.text == "‚ÑπÔ∏è –ü–æ–º–æ—â—å")
async def cmd_help(message: Message) -> None:
    if not await ensure_admin_message(message):
        return

    commands: Iterable[str] = (
        "/profiles ‚Äî —Å–ø–∏—Å–æ–∫ –ø—Ä–æ—Ñ–∏–ª–µ–π",
        "/parse <url> ‚Äî —Å–ø–∞—Ä—Å–∏—Ç—å –ø—Ä–æ–∏–∑–≤–æ–ª—å–Ω—ã–π URL",
        "/run <profile> ‚Äî –≤—ã–ø–æ–ª–Ω–∏—Ç—å –ø—Ä–æ—Ñ–∏–ª—å",
        "/results ‚Äî –ø–æ—Å–ª–µ–¥–Ω–∏–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã",
        "/export ‚Äî —ç–∫—Å–ø–æ—Ä—Ç –ø–æ—Å–ª–µ–¥–Ω–∏—Ö –¥–∞–Ω–Ω—ã—Ö",
    )
    help_text = build_help_section(commands)
    await message.answer(help_text, reply_markup=MAIN_MENU)


@router.message(Command("profiles"))
async def cmd_profiles(message: Message) -> None:
    if not await ensure_admin_message(message):
        return

    if not parsing_profiles:
        await message.answer("‚ùå –ü—Ä–æ—Ñ–∏–ª–∏ –Ω–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω—ã", reply_markup=MAIN_MENU)
        return

    lines: List[str] = ["üìã –î–æ—Å—Ç—É–ø–Ω—ã–µ –ø—Ä–æ—Ñ–∏–ª–∏:"]
    for key, profile in parsing_profiles.items():
        lines.append(f"üî∏ <code>{key}</code> ‚Äî {profile['name']}")

    await message.answer("\n".join(lines), reply_markup=MAIN_MENU)


@router.message(Command("parse"))
async def cmd_parse(message: Message) -> None:
    if not await ensure_admin_message(message):
        return

    args = message.text.split(" ", 1)
    if len(args) < 2:
        await message.answer("‚ùå –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: /parse <url>")
        return

    url = args[1].strip()
    await message.answer(f"üîÑ –ü–∞—Ä—Å–∏–º {url}‚Ä¶", reply_markup=ReplyKeyboardRemove())

    try:
        async with UniversalParser() as parser:
            results = await parser.parse_url(url)
    except Exception as exc:  # pragma: no cover - —Å–µ—Ç–µ–≤—ã–µ –æ—à–∏–±–∫–∏
        await message.answer(f"‚ùå –û—à–∏–±–∫–∞: {exc}", reply_markup=MAIN_MENU)
        return

    if not results:
        await message.answer("‚ùå –î–∞–Ω–Ω—ã–µ –Ω–µ –Ω–∞–π–¥–µ–Ω—ã", reply_markup=MAIN_MENU)
        return

    save_results("manual_parse", results)
    preview = json.dumps(results[:5], ensure_ascii=False, indent=2)
    text = f"‚úÖ –ù–∞–π–¥–µ–Ω–æ {len(results)} —ç–ª–µ–º–µ–Ω—Ç–æ–≤\n<pre>{preview}</pre>"
    await message.answer(text, reply_markup=MAIN_MENU)


async def _run_profile(profile_name: str) -> List[dict]:
    async with UniversalParser() as parser:
        return await parser.parse_by_profile(profile_name)


@router.message(Command("run"))
async def cmd_run(message: Message) -> None:
    if not await ensure_admin_message(message):
        return

    args = message.text.split(" ", 1)
    if len(args) < 2:
        await message.answer("‚ùå –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: /run <profile_name>")
        return

    profile_name = args[1].strip()
    if profile_name not in parsing_profiles:
        await message.answer(f"‚ùå –ü—Ä–æ—Ñ–∏–ª—å '{profile_name}' –Ω–µ –Ω–∞–π–¥–µ–Ω")
        return

    await message.answer(f"üîÑ –ó–∞–ø—É—Å–∫–∞–µ–º –ø—Ä–æ—Ñ–∏–ª—å '{profile_name}'‚Ä¶", reply_markup=ReplyKeyboardRemove())

    try:
        results = await _run_profile(profile_name)
    except Exception as exc:  # pragma: no cover - —Å–µ—Ç–µ–≤—ã–µ –æ—à–∏–±–∫–∏
        await message.answer(f"‚ùå –û—à–∏–±–∫–∞: {exc}", reply_markup=MAIN_MENU)
        return

    if not results:
        await message.answer("‚ùå –î–∞–Ω–Ω—ã–µ –Ω–µ –Ω–∞–π–¥–µ–Ω—ã", reply_markup=MAIN_MENU)
        return

    save_results(profile_name, results)
    text_lines = [
        f"‚úÖ –ü—Ä–æ—Ñ–∏–ª—å '{profile_name}' –≤—ã–ø–æ–ª–Ω–µ–Ω",
        f"–ù–∞–π–¥–µ–Ω–æ —ç–ª–µ–º–µ–Ω—Ç–æ–≤: {len(results)}",
    ]
    for idx, result in enumerate(results[:3], start=1):
        text_lines.append(f"{idx}. {json.dumps(result, ensure_ascii=False)}")
    if len(results) > 3:
        text_lines.append(f"‚Ä¶ –∏ –µ—â—ë {len(results) - 3} —ç–ª–µ–º–µ–Ω—Ç–æ–≤")

    await message.answer("\n".join(text_lines), reply_markup=MAIN_MENU)


async def _send_results(message: Message) -> None:
    results = get_recent_results(limit=100)
    if not results:
        await message.answer("‚ùå –†–µ–∑—É–ª—å—Ç–∞—Ç—ã –Ω–µ –Ω–∞–π–¥–µ–Ω—ã", reply_markup=MAIN_MENU)
        return

    text_lines = [f"üìä –ü–æ—Å–ª–µ–¥–Ω–∏–µ {len(results)} —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤:"]
    for result in results[:10]:
        text_lines.append(
            f"üî∏ {result['timestamp']} ‚Äî {result['profile_name']}: {result['count']} —ç–ª–µ–º–µ–Ω—Ç–æ–≤"
        )

    latest_profile = results[0]["profile_name"]
    await message.answer(
        "\n".join(text_lines),
        reply_markup=build_results_actions(latest_profile),
    )


@router.message(Command("results"))
@router.message(F.text == "üìä –ü–æ—Å–ª–µ–¥–Ω–∏–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã")
async def cmd_results(message: Message) -> None:
    if not await ensure_admin_message(message):
        return
    await _send_results(message)


@router.message(Command("export"))
async def cmd_export(message: Message) -> None:
    if not await ensure_admin_message(message):
        return

    results = get_recent_results(limit=1000)
    if not results:
        await message.answer("‚ùå –ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –¥–ª—è —ç–∫—Å–ø–æ—Ä—Ç–∞", reply_markup=MAIN_MENU)
        return

    dataframe = pd.DataFrame(results)
    buffer = io.BytesIO()
    with pd.ExcelWriter(buffer, engine="openpyxl") as writer:
        dataframe.to_excel(writer, index=False, sheet_name="Results")
    buffer.seek(0)

    file = BufferedInputFile(buffer.read(), filename="parsing_results.xlsx")
    await message.answer_document(file, caption=f"üìà –≠–∫—Å–ø–æ—Ä—Ç: {len(results)} –∑–∞–ø–∏—Å–µ–π")


@router.message(Command("alert"))
@router.message(F.text == "‚ûï –î–æ–±–∞–≤–∏—Ç—å –∞–ª–µ—Ä—Ç")
async def start_alert(message: Message, state: FSMContext) -> None:
    if not await ensure_admin_message(message):
        return

    await state.set_state(AlertScenario.waiting_for_name)
    await message.answer("–í–≤–µ–¥–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ –∞–ª–µ—Ä—Ç–∞:", reply_markup=ReplyKeyboardRemove())


@router.message(AlertScenario.waiting_for_name)
async def alert_name(message: Message, state: FSMContext) -> None:
    name = message.text.strip()
    if not name:
        await message.answer("–ù–∞–∑–≤–∞–Ω–∏–µ –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.")
        return

    await state.update_data(name=name)
    await state.set_state(AlertScenario.waiting_for_url)
    await message.answer("–£–∫–∞–∂–∏—Ç–µ URL, –∫–æ—Ç–æ—Ä—ã–π –Ω—É–∂–Ω–æ –æ—Ç—Å–ª–µ–∂–∏–≤–∞—Ç—å:")


@router.message(AlertScenario.waiting_for_url)
async def alert_url(message: Message, state: FSMContext) -> None:
    url = message.text.strip()
    if not url.startswith("http"):
        await message.answer("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ –∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π URL (http/https).")
        return

    await state.update_data(url=url)
    await state.set_state(AlertScenario.waiting_for_conditions)
    await message.answer("–ü–µ—Ä–µ—á–∏—Å–ª–∏—Ç–µ —É—Å–ª–æ–≤–∏—è/–∫–ª—é—á–µ–≤—ã–µ —Å–ª–æ–≤–∞ —á–µ—Ä–µ–∑ –∑–∞–ø—è—Ç—É—é:")


@router.message(AlertScenario.waiting_for_conditions)
async def alert_finish(message: Message, state: FSMContext) -> None:
    conditions = [item.strip() for item in message.text.split(",") if item.strip()]
    if not conditions:
        await message.answer("–ù—É–∂–Ω–æ —É–∫–∞–∑–∞—Ç—å —Ö–æ—Ç—è –±—ã –æ–¥–Ω–æ —É—Å–ª–æ–≤–∏–µ. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.")
        return

    data = await state.get_data()
    alert = Alert(name=data["name"], url=data["url"], conditions=conditions)
    add_alert(alert)
    await state.clear()

    text = (
        f"‚úÖ –ê–ª–µ—Ä—Ç ¬´{alert.name}¬ª —Å–æ—Ö—Ä–∞–Ω—ë–Ω."
        f"\nURL: {alert.url}"
        f"\n–£—Å–ª–æ–≤–∏—è: {', '.join(alert.conditions)}"
    )
    await message.answer(text, reply_markup=MAIN_MENU)


@router.message(Command("import"))
@router.message(F.text == "üì• –ò–º–ø–æ—Ä—Ç —Å–ø–∏—Å–∫–∞")
async def start_import(message: Message, state: FSMContext) -> None:
    if not await ensure_admin_message(message):
        return

    await state.set_state(ImportListScenario.waiting_for_payload)
    await message.answer(
        "–û—Ç–ø—Ä–∞–≤—å—Ç–µ —Å–ø–∏—Å–æ–∫ —Å—Å—ã–ª–æ–∫ –∏–ª–∏ –∑–Ω–∞—á–µ–Ω–∏–π. –ú–æ–∂–Ω–æ –≤—Å—Ç–∞–≤–∏—Ç—å —Ç–µ–∫—Å—Ç –±–ª–æ–∫–æ–º –∏–ª–∏ –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —Ñ–∞–π–ª .txt.",
        reply_markup=ReplyKeyboardRemove(),
    )


@router.message(ImportListScenario.waiting_for_payload)
async def import_payload(message: Message, state: FSMContext) -> None:
    content = message.text or message.caption
    if not content:
        await message.answer("–ù–µ —É–¥–∞–ª–æ—Å—å –ø—Ä–æ—á–∏—Ç–∞—Ç—å –¥–∞–Ω–Ω—ã–µ. –í—Å—Ç–∞–≤—å—Ç–µ —Ç–µ–∫—Å—Ç —Å–æ —Å–ø–∏—Å–∫–æ–º.")
        return

    parts = [item.strip() for item in content.replace(",", "\n").splitlines() if item.strip()]
    if not parts:
        await message.answer("–°–ø–∏—Å–æ–∫ –ø—É—Å—Ç. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.")
        return

    await state.update_data(items=parts)
    await state.set_state(ImportListScenario.waiting_for_confirmation)
    await message.answer(
        f"–ü–æ–ª—É—á–µ–Ω–æ {len(parts)} —ç–ª–µ–º–µ–Ω—Ç–æ–≤. –°–æ—Ö—Ä–∞–Ω–∏—Ç—å?",
        reply_markup=build_import_confirmation_keyboard(),
    )


@router.callback_query(ImportListScenario.waiting_for_confirmation, F.data == "import:confirm")
async def import_confirm(callback: CallbackQuery, state: FSMContext) -> None:
    if not await ensure_admin_callback(callback):
        return

    data = await state.get_data()
    items = data.get("items", [])
    register_import(ImportBatch(items=items))
    await state.clear()

    await callback.message.answer(
        f"‚úÖ –ò–º–ø–æ—Ä—Ç —Å–æ—Ö—Ä–∞–Ω—ë–Ω. –î–æ–±–∞–≤–ª–µ–Ω–æ {len(items)} —ç–ª–µ–º–µ–Ω—Ç–æ–≤.",
        reply_markup=MAIN_MENU,
    )
    await callback.answer("–ò–º–ø–æ—Ä—Ç —Å–æ—Ö—Ä–∞–Ω—ë–Ω")


@router.callback_query(ImportListScenario.waiting_for_confirmation, F.data == "import:cancel")
async def import_cancel(callback: CallbackQuery, state: FSMContext) -> None:
    if not await ensure_admin_callback(callback):
        return

    await state.clear()
    await callback.message.answer("–ò–º–ø–æ—Ä—Ç –æ—Ç–º–µ–Ω—ë–Ω.", reply_markup=MAIN_MENU)
    await callback.answer("–û—Ç–º–µ–Ω–µ–Ω–æ")


@router.callback_query(F.data.startswith("results:rerun:"))
async def results_rerun(callback: CallbackQuery) -> None:
    if not await ensure_admin_callback(callback):
        return

    _, _, profile_name = callback.data.partition("results:rerun:")
    profile_name = profile_name.strip()

    if profile_name not in parsing_profiles:
        await callback.message.answer(f"‚ùå –ü—Ä–æ—Ñ–∏–ª—å '{profile_name}' –Ω–µ –Ω–∞–π–¥–µ–Ω.")
        await callback.answer("–û—à–∏–±–∫–∞", show_alert=True)
        return

    try:
        results = await _run_profile(profile_name)
    except Exception as exc:  # pragma: no cover - —Å–µ—Ç–µ–≤—ã–µ –æ—à–∏–±–∫–∏
        await callback.message.answer(f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–ø—É—Å–∫–µ: {exc}")
        await callback.answer("–û—à–∏–±–∫–∞", show_alert=True)
        return

    if not results:
        await callback.message.answer("‚ùå –î–∞–Ω–Ω—ã–µ –Ω–µ –Ω–∞–π–¥–µ–Ω—ã")
        await callback.answer("–ì–æ—Ç–æ–≤–æ")
        return

    save_results(profile_name, results)
    await callback.message.answer(
        f"‚úÖ –ü–æ–≤—Ç–æ—Ä–Ω—ã–π –∑–∞–ø—É—Å–∫ –ø—Ä–æ—Ñ–∏–ª—è '{profile_name}' –∑–∞–≤–µ—Ä—à—ë–Ω. –ù–∞–π–¥–µ–Ω–æ {len(results)} —ç–ª–µ–º–µ–Ω—Ç–æ–≤.",
        reply_markup=MAIN_MENU,
    )
    await callback.answer("–ì–æ—Ç–æ–≤–æ")


@router.callback_query(F.data.startswith("results:export:"))
async def results_export(callback: CallbackQuery) -> None:
    if not await ensure_admin_callback(callback):
        return

    _, _, profile_name = callback.data.partition("results:export:")
    profile_name = profile_name.strip()

    results = [result for result in get_recent_results(limit=1000) if result["profile_name"] == profile_name]
    if not results:
        await callback.message.answer("‚ùå –ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –¥–ª—è —ç–∫—Å–ø–æ—Ä—Ç–∞ –ø–æ –≤—ã–±—Ä–∞–Ω–Ω–æ–º—É –ø—Ä–æ—Ñ–∏–ª—é.")
        await callback.answer("–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö", show_alert=True)
        return

    dataframe = pd.DataFrame(results)
    buffer = io.BytesIO()
    with pd.ExcelWriter(buffer, engine="openpyxl") as writer:
        dataframe.to_excel(writer, index=False, sheet_name=profile_name[:31] or "Results")
    buffer.seek(0)

    file = BufferedInputFile(buffer.read(), filename=f"{profile_name}_results.xlsx")
    await callback.message.answer_document(file, caption=f"üìà –≠–∫—Å–ø–æ—Ä—Ç –ø—Ä–æ—Ñ–∏–ª—è {profile_name}")
    await callback.answer("–≠–∫—Å–ø–æ—Ä—Ç –≥–æ—Ç–æ–≤")


dp.include_router(router)


async def start_bot() -> None:
    print("ü§ñ Telegram –±–æ—Ç –∑–∞–ø—É—â–µ–Ω!")
    await dp.start_polling(bot)


if __name__ == "__main__":
    asyncio.run(start_bot())
